// Better French - Main JavaScript File

class BetterFrenchApp {
    constructor() {
        this.currentMode = 'learner';
        this.articles = [];
        this.filteredArticles = [];
        this.displayedArticles = 0;
        this.articlesPerPage = 12;
        this.currentTooltip = null;
        
        this.init();
    }

    async init() {
        this.setupEventListeners();
        await this.loadLatestData();
        this.renderArticles();
        this.setupArticleInteractions();

        // Expose a flag for automated QA scripts to know the page is fully rendered
        if (typeof window !== 'undefined') {
            window.__BF_LOADED = true;
        }
    }

    setupEventListeners() {
        // Mode toggle - Desktop buttons
        const modeButtons = document.querySelectorAll('.mode-option');
        modeButtons.forEach(button => {
            button.addEventListener('click', (e) => this.switchMode(e.target.dataset.mode));
        });

        // Mode toggle - Mobile switcher
        const modeSwitcher = document.querySelector('.mode-switcher');
        if (modeSwitcher) {
            modeSwitcher.addEventListener('click', () => this.toggleMobileMode());
        }

        // Search functionality
        const searchInput = document.querySelector('.search-input');
        searchInput.addEventListener('input', (e) => this.handleSearch(e.target.value));

        // Mobile collapsible search
        const searchIcon = document.querySelector('.search-icon');
        if (searchIcon) {
            searchIcon.addEventListener('click', () => this.toggleMobileSearch());
        }

        // Close search when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-container')) {
                this.closeMobileSearch();
            }
        });

        // Load more button
        const loadMoreBtn = document.getElementById('load-more');
        loadMoreBtn.addEventListener('click', () => this.loadMoreArticles());

        // Retry button
        const retryBtn = document.getElementById('retry-btn');
        retryBtn.addEventListener('click', () => this.init());

        // Summary toggles - Toggle behavior (open if closed, close if open)
        document.addEventListener('click', (e) => {
            if (e.target.closest('.summary-toggle')) {
                const toggle = e.target.closest('.summary-toggle');
                const summaryId = toggle.getAttribute('aria-controls');
                const summaryContent = document.getElementById(summaryId);
                if (summaryContent) {
                    const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
                    
                    if (isExpanded) {
                        // Currently open - close it
                        this.closeSummary(toggle, summaryContent);
                    } else {
                        // Currently closed - open it
                        this.openSummary(toggle, summaryContent);
                    }
                }
            }
        });
    }

    async loadLatestData() {
        try {
            this.showLoading(true);
            this.hideError();
            
            console.log('Loading AI-enhanced rolling collection...');

            // Resolve which data file to load (allows easy switching between
            // production and local-test datasets)
            const dataFile = await this.getLatestProcessedFile();

            // Load the collection generated by backend / local test fixture
            const cacheBust = `v=${Date.now()}`;
            const sep = dataFile.includes('?') ? '&' : '?';
            const response = await fetch(`${dataFile}${sep}${cacheBust}`);
            if (!response.ok) {
                throw new Error(`Failed to load articles: ${response.status}`);
            }
            
            const data = await response.json();
            this.articles = data.articles || [];
            // Exclude articles that have not yet been AI-enhanced to avoid duplicate titles and missing context
            this.articles = this.articles.filter(a => a.ai_enhanced || a.contextual_title_explanations);
            this.filteredArticles = [...this.articles];
            
            // Attach feed timestamp to cache bust so UI auto-refreshes when Pages deploys.
            const metaTs = data.metadata && data.metadata.updated_at ? Date.parse(data.metadata.updated_at) : Date.now();
            this.articlesPerPage = this.filteredArticles.length;
            this.feedTimestamp = metaTs; // store for future if needed
            
            console.log(`Loaded ${this.articles.length} AI-enhanced articles with contextual learning`);
            
        } catch (error) {
            console.error('Error loading articles:', error);
            this.showError();
        } finally {
            this.showLoading(false);
        }
    }

    async getLatestProcessedFile() {
        /*
         * Decide which JSON file to load:
         * 1. Always try live `rolling_articles.json` first – this is what the
         *    AI-Engine v2 pipeline writes.
         * 2. When running locally (localhost / file://) fall back to the small
         *    `test_articles.json` fixture *only if* the rolling file does not
         *    exist yet. This keeps dev UX smooth while still showing fresh
         *    data as soon as it's generated.
         */

        const LIVE_DATA = './rolling_articles.json';
        const TEST_DATA = './test_articles.json';

        try {
            const host = typeof window !== 'undefined' ? window.location.hostname : '';
            const isLocal = host === 'localhost' || host === '127.0.0.1' || host === '';

            // Always attempt to fetch live data first
            const headResp = await fetch(LIVE_DATA, { method: 'HEAD' }).catch(() => null);
            if (headResp && headResp.ok) {
                return LIVE_DATA;
            }

            // If running locally and live file missing, fall back to fixture
            if (isLocal) {
                return TEST_DATA;
            }

            // Production but file missing (should not happen) – still return live path
            return LIVE_DATA;
        } catch (err) {
            // Safe fallback – never break rendering just because env detection failed
            return LIVE_DATA;
        }
    }

    toggleMobileMode() {
        const currentMode = this.currentMode;
        const newMode = currentMode === 'learner' ? 'native' : 'learner';
        this.switchMode(newMode);
    }

    switchMode(mode) {
        if (mode === this.currentMode) return;

        const oldMode = this.currentMode;
        this.currentMode = mode;

        // Update desktop button states
        document.querySelectorAll('.mode-option').forEach(btn => {
            const isActive = btn.dataset.mode === mode;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-checked', isActive.toString());
        });

        // Update mobile switcher
        this.updateMobileSwitcher(mode);

        // Animate mode switch
        this.animateModeSwitch(oldMode, mode);
    }

    updateMobileSwitcher(mode) {
        const modeSwitcher = document.querySelector('.mode-switcher');
        const modeIcon = modeSwitcher?.querySelector('.mode-icon');
        const modeText = modeSwitcher?.querySelector('.mode-text');
        
        if (modeSwitcher && modeIcon && modeText) {
            modeSwitcher.setAttribute('data-current-mode', mode);
            
            // Smooth transition with flip effect
            modeSwitcher.style.transform = 'scale(0.9)';
            
            setTimeout(() => {
                if (mode === 'learner') {
                    modeIcon.textContent = '🎓';
                    modeText.textContent = 'Learner';
                } else {
                    modeIcon.textContent = '🇫🇷';
                    modeText.textContent = 'Native';
                }
                
                modeSwitcher.style.transform = 'scale(1.0)';
            }, 150);
        }
    }

    animateModeSwitch(oldMode, newMode) {
        // Simply re-render all cards; this guarantees that titles and
        // summaries match the current mode and keeps interactive spans intact.
        this.renderArticles();
    }

    handleSearch(query) {
        const searchTerm = query.toLowerCase().trim();
        
        if (searchTerm === '') {
            this.filteredArticles = [...this.articles];
        } else {
            this.filteredArticles = this.articles.filter(article => 
                article.original_article_title.toLowerCase().includes(searchTerm) ||
                article.simplified_english_title.toLowerCase().includes(searchTerm) ||
                article.simplified_french_title.toLowerCase().includes(searchTerm)
            );
        }

        this.displayedArticles = 0;
        this.renderArticles();
    }

    renderArticles() {
        console.log('renderArticles called');
        console.log('this.articles.length:', this.articles.length);
        console.log('this.filteredArticles.length:', this.filteredArticles.length);
        
        const featuredContainer = document.getElementById('featured-article');
        const articlesContainer = document.getElementById('articles-container');
        const loadMoreBtn = document.getElementById('load-more');

        console.log('DOM elements found:', {
            featuredContainer: !!featuredContainer,
            articlesContainer: !!articlesContainer,
            loadMoreBtn: !!loadMoreBtn
        });

        // Clear existing content
        featuredContainer.innerHTML = '';
        articlesContainer.innerHTML = '';

        if (this.filteredArticles.length === 0) {
            console.log('No filtered articles, showing "no articles" message');
            featuredContainer.innerHTML = '<p>No articles found matching your search.</p>';
            loadMoreBtn.style.display = 'none';
            return;
        }

        console.log('Rendering articles...');
        
        // Render featured article (first article)
        const featuredArticle = this.filteredArticles[0];
        console.log('Featured article:', featuredArticle);
        featuredContainer.innerHTML = this.createArticleHTML(featuredArticle, true);

        // Render regular articles
        const articlesToShow = Math.min(this.articlesPerPage, this.filteredArticles.length - 1);
        this.displayedArticles = articlesToShow + 1; // +1 for featured
        
        console.log('Articles to show:', articlesToShow);

        for (let i = 1; i <= articlesToShow; i++) {
            const article = this.filteredArticles[i];
            const articleElement = document.createElement('article');
            articleElement.className = 'article-card';
            articleElement.innerHTML = this.createArticleHTML(article, false);
            articlesContainer.appendChild(articleElement);
        }

        // Show/hide load more button
        loadMoreBtn.style.display = this.displayedArticles < this.filteredArticles.length ? 'block' : 'none';

        // Setup article interactions
        this.setupArticleInteractions();
    }

    loadMoreArticles() {
        const articlesContainer = document.getElementById('articles-container');
        const loadMoreBtn = document.getElementById('load-more');
        
        const startIndex = this.displayedArticles;
        const endIndex = Math.min(startIndex + this.articlesPerPage, this.filteredArticles.length);

        for (let i = startIndex; i < endIndex; i++) {
            const article = this.filteredArticles[i];
            const articleElement = document.createElement('article');
            articleElement.className = 'article-card';
            articleElement.style.opacity = '0';
            articleElement.innerHTML = this.createArticleHTML(article, false);
            articlesContainer.appendChild(articleElement);

            // Fade in animation
            setTimeout(() => {
                articleElement.style.transition = 'opacity 200ms ease-in';
                articleElement.style.opacity = '1';
            }, 50);
        }

        this.displayedArticles = endIndex;
        
        // Hide load more button if all articles are displayed
        if (this.displayedArticles >= this.filteredArticles.length) {
            loadMoreBtn.style.display = 'none';
        }

        this.setupArticleInteractions();
    }

    createArticleHTML(article, isFeatured = false) {
        // Handle both AI-enhanced articles and basic curated articles
        const isAIEnhanced = article.ai_enhanced || !!article.contextual_title_explanations;
        
        // Primary (big) title should now be the simplified / translated one
        let primaryTitleRaw;
        if (isAIEnhanced) {
            primaryTitleRaw = this.currentMode === 'learner'
                ? article.simplified_english_title
                : article.simplified_french_title;
        } else {
            primaryTitleRaw = article.title || 'Untitled Article';
        }

        const primaryTitle = primaryTitleRaw;

        // Secondary (smaller) title will show the original headline in French (interactive)
        const secondaryTitleRaw = article.original_article_title || article.title || 'Untitled Article';
        const secondaryTitle = this.createInteractiveTitle(secondaryTitleRaw, article.contextual_title_explanations);
        
        // For summary, use AI fields if available, otherwise use basic summary
        let summaryText;
        let summaryLabel;
        if (isAIEnhanced) {
            summaryText = this.currentMode === 'learner' 
                ? article.english_summary 
                : article.french_summary;
            summaryLabel = this.currentMode === 'learner' 
                ? 'Summary' 
                : 'Résumé';
        } else {
            // For basic articles, use the summary field or fallback
            summaryText = article.summary || 'Summary not available';
            summaryLabel = this.currentMode === 'learner' 
                ? 'Summary' 
                : 'Résumé';
        }

        // Extract source from the appropriate link field
        const articleLink = article.original_article_link || article.link;
        const source = this.extractSource(articleLink);
        
        // Try multiple date fields in order of preference
        const publishedDate = this.formatDate(
            article.published || 
            article.published_date || 
            article.original_article_published_date
        );
        
        // Generate unique IDs for accessibility
        const summaryId = this.generateId();
        const collapseId = this.generateId();

        // Only show summary section if we have content
        const showSummary = summaryText && summaryText !== 'Summary not available' && summaryText.trim().length > 0;

        return `
            <h2 class="article-title">${primaryTitle}</h2>
            ${showSummary ? `
                <p class="summary-text"><strong>${summaryLabel}:</strong> ${summaryText}</p>
            ` : ''}
            <h3 class="secondary-title">${secondaryTitle}</h3>
            <div class="article-meta">${source} | ${publishedDate}</div>
            <button class="collapse-button" id="${collapseId}" aria-label="Close summary" style="display: none;">—</button>
        `;
    }

    extractSource(url) {
        if (!url) return 'Unknown Source';
        
        try {
            const urlObj = new URL(url);
            const hostname = urlObj.hostname.toLowerCase();
            
            // Map common domains to readable names
            const sourceMap = {
                'www.lexpress.fr': 'L\'Express',
                'lexpress.fr': 'L\'Express',
                'www.lemonde.fr': 'Le Monde',
                'lemonde.fr': 'Le Monde',
                'www.france24.com': 'France 24',
                'france24.com': 'France 24',
                'www.rfi.fr': 'RFI',
                'rfi.fr': 'RFI',
                'www.liberation.fr': 'Libération',
                'liberation.fr': 'Libération'
            };
            
            return sourceMap[hostname] || hostname.replace('www.', '').split('.')[0];
        } catch (error) {
            return 'Unknown Source';
        }
    }

    createInteractiveTitle(title, explanations) {
        if (!explanations || Object.keys(explanations).length === 0) {
            return title;
        }

        // SAFETY CHECK: Ensure explanations is isolated to this article only
        const explanationKeys = Object.keys(explanations);
        
        // Convert object format to array format for processing
        const explanationArray = Object.entries(explanations).map(([word, data]) => ({
            original_word: word,
            ...data
        }));

        // Debug: Show which article and explanations we're working with
        console.log('🔍 Processing Title:', title.substring(0, 60) + '...');
        console.log('📚 Available explanations for THIS article:', explanationKeys);
        
        // Debug: Check for accented words specifically
        const accentedWords = explanationKeys.filter(word => /[À-ÿ]/.test(word));
        if (accentedWords.length > 0) {
            console.log('🎯 Accented words to match:', accentedWords);
        }

        // Sort explanations by word length (longest first) to match phrases before individual words
        const sortedExplanations = explanationArray.slice().sort((a, b) => 
            b.original_word.length - a.original_word.length
        );

        // Track all matches with their positions
        let matches = [];
        
        // Find all potential matches
        sortedExplanations.forEach(exp => {
            const originalWord = exp.original_word;
            
            // Create regex to find the word/phrase (case insensitive, whole word boundaries)
            const isMultiWord = originalWord.includes(' ');
            let regexPattern;
            
            if (isMultiWord) {
                // For phrases like "sur la table", match the exact sequence
                regexPattern = originalWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            } else {
                // For single words, create patterns that handle quotes and plural forms
                let escapedWord = originalWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Allow straight (') and curly (') apostrophes interchangeably
                escapedWord = escapedWord.replace(/['\u2019]/g, "[\\u2019']");
                // Allow optional 's' at end for plurals and optional straight/curly quotes around the word
                regexPattern = `["'“”]?${escapedWord}s?["'“”]?`;
            }
            
            // Debug logging for problematic words
            if (/[À-ÿ]/.test(originalWord) || ['océan', 'ébullition', 'mobilisation', 'organisée', 'invité'].includes(originalWord)) {
                console.log(`🔍 Searching for "${originalWord}" with pattern: ${regexPattern}`);
            }
            
            const regex = new RegExp(regexPattern, 'gi');
            
            // Also try a looser match without strict word boundaries for French punctuation
            const looseRegex = new RegExp(regexPattern, 'gi');
            let match;
            
            // Find all matches for this explanation using primary regex
            while ((match = regex.exec(title)) !== null) {
                // Strip quotes if present
                let cleanText = match[0];
                let adjustedStart = match.index;
                let adjustedEnd = match.index + match[0].length;
                
                // For single words, check if the match includes quotes
                if (!isMultiWord) {
                    const startQuote = cleanText.match(/^['"“"]/);
                    const endQuote = cleanText.match(/['"“"]$/);
                    
                    if (startQuote) {
                        cleanText = cleanText.substring(1);
                        adjustedStart += 1;
                    }
                    if (endQuote) {
                        cleanText = cleanText.substring(0, cleanText.length - 1);
                        adjustedEnd -= 1;
                    }
                }
                
                // Validate that this is a complete word match (not part of a larger word)
                const charBefore = adjustedStart > 0 ? title[adjustedStart - 1] : '';
                const charAfter = adjustedEnd < title.length ? title[adjustedEnd] : '';
                
                // French letter pattern (includes accented characters)
                const frenchLetterPattern = /[a-zA-ZÀ-ÿ]/;
                
                // For single words, ensure it's not part of a larger word
                const isValidMatch = isMultiWord || 
                    (!frenchLetterPattern.test(charBefore) && !frenchLetterPattern.test(charAfter));
                
                if (isValidMatch) {
                    matches.push({
                        start: adjustedStart,
                        end: adjustedEnd,
                        text: cleanText,
                        explanation: exp,
                        length: cleanText.length,
                        source: 'primary'
                    });
                } else {
                    // Debug: Log failed word boundary checks for accented words
                    if (/[À-ÿ]/.test(exp.original_word)) {
                        console.log(`⚠️ Word boundary failed for "${exp.original_word}": before="${charBefore}" after="${charAfter}"`);
                    }
                }
            }
            
            // Also try looser regex for words that might have punctuation issues
            if (!isMultiWord) {
                looseRegex.lastIndex = 0; // Reset looser regex
                while ((match = looseRegex.exec(title)) !== null) {
                    // Strip quotes if present
                    let cleanText = match[0];
                    let adjustedStart = match.index;
                    let adjustedEnd = match.index + match[0].length;
                    
                    const startQuote = cleanText.match(/^['"“"]/);
                    const endQuote = cleanText.match(/['"“"]$/);
                    
                    if (startQuote) {
                        cleanText = cleanText.substring(1);
                        adjustedStart += 1;
                    }
                    if (endQuote) {
                        cleanText = cleanText.substring(0, cleanText.length - 1);
                        adjustedEnd -= 1;
                    }
                    
                    // Validate this match too
                    const charBefore = adjustedStart > 0 ? title[adjustedStart - 1] : '';
                    const charAfter = adjustedEnd < title.length ? title[adjustedEnd] : '';
                    const frenchLetterPattern = /[a-zA-ZÀ-ÿ]/;
                    const isValidMatch = !frenchLetterPattern.test(charBefore) && !frenchLetterPattern.test(charAfter);
                    
                    // Only add if not already found by primary regex and is valid
                    const alreadyFound = matches.some(m => 
                        Math.abs(m.start - adjustedStart) < 2 && 
                        m.explanation.original_word === exp.original_word
                    );
                    
                    if (!alreadyFound && isValidMatch) {
                        matches.push({
                            start: adjustedStart,
                            end: adjustedEnd,
                            text: cleanText,
                            explanation: exp,
                            length: cleanText.length,
                            source: 'loose'
                        });
                    }
                }
                
                // AGGRESSIVE FALLBACK: Try to find word even inside quotes or with spaces
                if (matches.filter(m => m.explanation.original_word === exp.original_word).length === 0) {
                    // Create a very permissive regex that handles quotes and plurals
                    const escapedWord = originalWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/['\u2019]/g, "[\\u2019']");
                    // Match word with optional quotes (regular or curly) and optional 's' for plural
                    const veryLoosePattern = `["'“”]?${escapedWord}s?["'“”]?`;
                    const veryLooseRegex = new RegExp(veryLoosePattern, 'gi');
                    veryLooseRegex.lastIndex = 0;
                    
                    while ((match = veryLooseRegex.exec(title)) !== null) {
                        const alreadyFound = matches.some(m => 
                            Math.abs(m.start - match.index) < 2 && 
                            m.explanation.original_word === exp.original_word
                        );
                        
                        if (!alreadyFound) {
                            // Strip quotes from the matched text for cleaner display
                            let cleanText = match[0];
                            const startQuote = cleanText.match(/^['"“"]/);
                            const endQuote = cleanText.match(/['"“"]$/);
                            let adjustedStart = match.index;
                            let adjustedEnd = match.index + match[0].length;
                            
                            // If we have quotes, adjust the match to exclude them
                            if (startQuote) {
                                cleanText = cleanText.substring(1);
                                adjustedStart += 1;
                            }
                            if (endQuote) {
                                cleanText = cleanText.substring(0, cleanText.length - 1);
                                adjustedEnd -= 1;
                            }
                            
                            matches.push({
                                start: adjustedStart,
                                end: adjustedEnd,
                                text: cleanText,
                                explanation: exp,
                                length: cleanText.length,
                                source: 'aggressive'
                            });
                            
                            // Debug logging for aggressive matches
                            if (/[À-ÿ]/.test(originalWord) || ['océan', 'ébullition', 'mobilisation', 'organisée', 'invité'].includes(originalWord)) {
                                console.log(`🚀 AGGRESSIVE match found for "${originalWord}": "${match[0]}" → cleaned: "${cleanText}"`);
                            }
                        }
                    }
                }
            }

            // NEW AGGRESSIVE FALLBACK FOR MULTI-WORD PHRASES
            if (isMultiWord && matches.filter(m => m.explanation.original_word === exp.original_word).length === 0) {
                // Extremely permissive pattern: ignore straight vs curly quotes
                // and allow optional leading/trailing quotes around the phrase.
                const escapedPhrase = originalWord
                    .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
                    .replace(/['\u2019]/g, "[\\u2019']");

                const veryLooseRegex = new RegExp(`["'“”]?${escapedPhrase}["'“”]?`, 'gi');
                let looseMatch;
                while ((looseMatch = veryLooseRegex.exec(title)) !== null) {
                    const alreadyFound = matches.some(m =>
                        Math.abs(m.start - looseMatch.index) < 2 &&
                        m.explanation.original_word === exp.original_word
                    );
                    if (!alreadyFound) {
                        const cleaned = looseMatch[0].replace(/^['"“”]|['"“”]$/g, '');
                        matches.push({
                            start: looseMatch.index,
                            end: looseMatch.index + looseMatch[0].length,
                            text: cleaned,
                            explanation: exp,
                            length: cleaned.length,
                            source: 'aggressive-phrase'
                        });
                    }
                }
            }
        });

        // Sort matches by position (earliest first)
        matches.sort((a, b) => a.start - b.start);

        // Remove overlapping matches (keep longer/earlier ones)
        let filteredMatches = [];
        for (let i = 0; i < matches.length; i++) {
            const currentMatch = matches[i];
            let hasOverlap = false;
            
            // Check if this match overlaps with any already accepted match
            for (let j = 0; j < filteredMatches.length; j++) {
                const existingMatch = filteredMatches[j];
                
                // Check for overlap: if current match starts before existing ends and ends after existing starts
                if (currentMatch.start < existingMatch.end && currentMatch.end > existingMatch.start) {
                    hasOverlap = true;
                    break;
                }
            }
            
            // Only add if no overlap
            if (!hasOverlap) {
                filteredMatches.push(currentMatch);
            }
        }

        // Sort filtered matches by position (latest first for replacement)
        filteredMatches.sort((a, b) => b.start - a.start);

        // VALIDATION: Only apply matches that belong to THIS article's explanations
        const validatedMatches = filteredMatches.filter(match => {
            const wordExists = explanationKeys.includes(match.explanation.original_word);
            if (!wordExists) {
                console.warn(`🚨 BLOCKED cross-contamination: "${match.text}" not in current article explanations`);
            }
            return wordExists;
        });

        // Apply matches from end to beginning to preserve positions
        let result = title;
        
        // Debug logging
        if (validatedMatches.length > 0) {
            console.log('✅ Valid matches for this article:', validatedMatches.map(m => `"${m.text}"`));
        } else {
            console.log('ℹ️ No matches found for this article');
        }
        
        validatedMatches.forEach(match => {
            const beforeMatch = result.substring(0, match.start);
            const afterMatch = result.substring(match.end);
            const wrappedMatch = `<span class="french-word" data-word="${encodeURIComponent(JSON.stringify(match.explanation))}">${match.text}</span>`;
            
            result = beforeMatch + wrappedMatch + afterMatch;
        });

        // ------- Diagnostic: list any tokens still not wrapped ---------
        const wrappedKeys = validatedMatches.map(m => m.explanation.original_word);
        const unmatched = explanationKeys.filter(k => !wrappedKeys.includes(k));
        if (unmatched.length > 0) {
            console.warn('🚩 Unmatched tokens after final pass:', unmatched);
        }

        return result;
    }

    // Advanced word normalization for better matching
    normalizeWord(word) {
        if (!word) return '';
        
        return word
            .toLowerCase()
            // Remove all punctuation and special characters
            .replace(/[^\w\s\u00C0-\u017F]/g, '')
            // Normalize accented characters
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            // Remove extra whitespace
            .trim();
    }

    setupArticleInteractions() {
        // (Hover-to-open disabled; user must click the Summary button)

        // Collapse button - Click to close
        document.addEventListener('click', (e) => {
            if (e.target.closest('.collapse-button')) {
                const card = e.target.closest('.article-card');
                const summaryToggle = card.querySelector('.summary-toggle');
                const summaryContent = card.querySelector('.summary-content');
                if (summaryToggle && summaryContent) {
                    this.closeSummary(summaryToggle, summaryContent);
                }
            }
        });

        // Enhanced French word interactions with focus management
        this.setupFrenchWordInteractions();

        // Toggle summary visibility on main headline click
        document.querySelectorAll('.article-title').forEach(titleEl => {
            if (titleEl.dataset.summaryBound) return;
            titleEl.dataset.summaryBound = 'true';

            titleEl.addEventListener('click', () => {
                const card = titleEl.closest('.article-card');
                if (!card) return;
                const summary = card.querySelector('.summary-text');
                if (!summary) return;

                const expanded = summary.classList.toggle('expanded');
                // If expanding, ensure it is visible for the animation
                if (expanded) {
                    summary.style.maxHeight = summary.scrollHeight + 'px';
                } else {
                    // reset max-height so next open can compute correctly
                    summary.style.maxHeight = '0';
                }
            });
        });
    }

    setupFrenchWordInteractions() {
        document.querySelectorAll('.french-word').forEach(word => {
            word.setAttribute('tabindex', '0');
            word.setAttribute('role', 'button');
            
            // Desktop: hover events
            word.addEventListener('mouseenter', (e) => {
                this.setActiveWord(e.target);
            });
            
            word.addEventListener('mouseleave', (e) => {
                this.clearActiveWord(e.target);
            });
            
            // Mobile: touch/click events
            word.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent mouse events on mobile
                this.setActiveWord(e.target);
            });
            
            word.addEventListener('click', (e) => {
                // Toggle active state on click (useful for mobile)
                if (e.target.classList.contains('active')) {
                    this.clearActiveWord(e.target);
                } else {
                    this.setActiveWord(e.target);
                }
            });
            
            // Keyboard navigation
            word.addEventListener('focus', (e) => {
                this.setActiveWord(e.target);
            });
            
            word.addEventListener('blur', (e) => {
                this.clearActiveWord(e.target);
            });
        });
        
        // Clear active word when clicking outside
        document.addEventListener('touchstart', (e) => {
            if (!e.target.closest('.french-word')) {
                this.clearAllActiveWords();
            }
        });
        
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.french-word')) {
                this.clearAllActiveWords();
            }
        });
    }

    setActiveWord(wordElement) {
        // Active-state should be applied relative to the secondary title that
        // actually contains the interactive <span class="french-word"> nodes.
        // (The primary title .article-title only shows the simplified English/French
        //  version and therefore does not include interactive spans.)
        const titleContainer = wordElement.closest('.secondary-title');
        if (titleContainer) {
            titleContainer.querySelectorAll('.french-word').forEach(w => {
                w.classList.remove('active');
            });
            
            // Set the new active word
            wordElement.classList.add('active');
            
            // Add fallback class for browsers without :has() support
            titleContainer.classList.add('has-active-word');
        }
    }

    clearActiveWord(wordElement) {
        const titleContainer = wordElement.closest('.secondary-title');
        if (titleContainer) {
            wordElement.classList.remove('active');
            
            // Check if any other words are still active
            const hasActiveWords = titleContainer.querySelectorAll('.french-word.active').length > 0;
            if (!hasActiveWords) {
                titleContainer.classList.remove('has-active-word');
            }
        }
    }

    clearAllActiveWords() {
        document.querySelectorAll('.french-word.active').forEach(word => {
            word.classList.remove('active');
        });
        document.querySelectorAll('.secondary-title.has-active-word').forEach(title => {
            title.classList.remove('has-active-word');
        });
    }

    openSummary(toggleButton, summaryContent) {
        const chevron = toggleButton.querySelector('.chevron');
        const collapseButton = toggleButton.closest('.article-card').querySelector('.collapse-button');
        const isExpanded = toggleButton.getAttribute('aria-expanded') === 'true';
        
        // Only open if not already expanded
        if (isExpanded) return;

        // Update attributes to expanded state
        toggleButton.setAttribute('aria-expanded', 'true');
        summaryContent.setAttribute('aria-hidden', 'false');

        // Toggle classes and animations
        if (chevron) chevron.classList.add('expanded');
        summaryContent.classList.add('expanded');

        // Show collapse button
        if (collapseButton) {
            collapseButton.style.display = 'flex';
        }

        // Handle height animation for opening
        summaryContent.style.height = 'auto';
        const height = summaryContent.scrollHeight;
        summaryContent.style.height = '0';
        summaryContent.offsetHeight; // Force reflow
        summaryContent.style.height = height + 'px';
        
        // Set back to auto after animation
        setTimeout(() => {
            if (summaryContent.classList.contains('expanded')) {
                summaryContent.style.height = 'auto';
            }
        }, 200);
    }

    closeSummary(toggleButton, summaryContent) {
        const chevron = toggleButton.querySelector('.chevron');
        const collapseButton = toggleButton.closest('.article-card').querySelector('.collapse-button');
        const isExpanded = toggleButton.getAttribute('aria-expanded') === 'true';
        
        // Only close if currently expanded
        if (!isExpanded) return;

        // Update attributes to collapsed state
        toggleButton.setAttribute('aria-expanded', 'false');
        summaryContent.setAttribute('aria-hidden', 'true');

        // Toggle classes and animations
        if (chevron) chevron.classList.remove('expanded');
        summaryContent.classList.remove('expanded');

        // Hide collapse button
        if (collapseButton) {
            collapseButton.style.display = 'none';
        }

        // Handle height animation for closing
        const height = summaryContent.scrollHeight;
        summaryContent.style.height = height + 'px';
        summaryContent.offsetHeight; // Force reflow
        summaryContent.style.height = '0';
    }

    formatDate(dateString) {
        if (!dateString || dateString.trim() === '') {
            // Use current date instead of hardcoded old date
            return new Date().toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }
        
        try {
            const date = new Date(dateString);
            if (isNaN(date.getTime())) {
                // Use current date instead of hardcoded old date
                return new Date().toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            }
            return date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        } catch (error) {
            // Use current date instead of hardcoded old date
            return new Date().toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }
    }

    generateId() {
        return 'summary-' + Math.random().toString(36).substr(2, 9);
    }

    showLoading(show) {
        const loading = document.getElementById('loading');
        loading.setAttribute('aria-hidden', (!show).toString());
        loading.style.display = show ? 'flex' : 'none';
    }

    showError() {
        const error = document.getElementById('error-message');
        error.setAttribute('aria-hidden', 'false');
        error.style.display = 'flex';
    }

    hideError() {
        const error = document.getElementById('error-message');
        error.setAttribute('aria-hidden', 'true');
        error.style.display = 'none';
    }

    toggleMobileSearch() {
        const searchInput = document.querySelector('.search-input');
        const searchIcon = document.querySelector('.search-icon');
        
        if (searchInput.classList.contains('expanded')) {
            this.closeMobileSearch();
        } else {
            this.openMobileSearch();
        }
    }

    openMobileSearch() {
        const searchInput = document.querySelector('.search-input');
        const searchIcon = document.querySelector('.search-icon');
        
        searchInput.classList.add('expanded');
        searchIcon.classList.add('active');
        
        // Focus the input after animation
        setTimeout(() => {
            searchInput.focus();
        }, 200);
    }

    closeMobileSearch() {
        const searchInput = document.querySelector('.search-input');
        const searchIcon = document.querySelector('.search-icon');
        
        if (searchInput && searchIcon) {
            searchInput.classList.remove('expanded');
            searchIcon.classList.remove('active');
            searchInput.blur();
        }
    }
}

// Initialize the app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new BetterFrenchApp();
}); 